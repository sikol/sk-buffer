/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_BUFFER_FIXED_BUFFER_HXX_INCLUDED
#define SK_BUFFER_FIXED_BUFFER_HXX_INCLUDED

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <ranges>
#include <span>
#include <type_traits>
#include <array>

#include "sk/buffer/buffer.hxx"

namespace sk {

    /*************************************************************************
     *
     * A fixed_buffer contains a fixed-size memory region.  Reads fill up the
     * buffer, and writes drain it, while moving the read and write windows
     * from the start of the buffer to the end.  Once the entire buffer has
     * been filled, it cannot be used until reset() is called to return it to
     * the empty state.
     * 
     */

    template <typename Char, std::size_t buffer_size> struct fixed_buffer {
        using array_type = std::array<Char, buffer_size>;
        using value_type = typename array_type::value_type;
        using const_value_type = std::add_const_t<value_type>;
        using iterator = typename array_type::iterator;
        using size_type = typename array_type::size_type;

        // Create a new, empty buffer.
        fixed_buffer()
            : data(data_array)
            , read_window(std::ranges::begin(data), 0)
            , write_window(data) {}

        // fixed_buffer cannot be copied or moved, because the buffer contains
        // the entire std::array<>.  In principle we could allow copying, but
        // copying a buffer is almost certainly a programming error.

        fixed_buffer(fixed_buffer const &) = delete;
        fixed_buffer &operator=(fixed_buffer const &) = delete;
        fixed_buffer(fixed_buffer &&) = delete;
        fixed_buffer &operator=(fixed_buffer &&) = delete;

        // The data stored in this buffer.
        std::array<Char, buffer_size> data_array;

        // A span of the the entire data.
        std::span<Char, buffer_size> data;

        // The read_window is the area of this extent that could be
        // read from.  If read_window.size() == 0, then this extent
        // has been completely used and should be discarded.
        std::span<Char> read_window;

        // The write_window is the area of this extent that could be
        // written to.
        std::span<Char> write_window;

        // reset(): reset this extent to empty, discarding any data it contains.
        auto reset() -> void;

        // write(): write some data into this buffer and adjust the write
        // window.  Returns the number of objects written.  If the buffer is too
        // small to contain all the data, the return value will be less than the
        // range size.

        template <std::ranges::contiguous_range InRange>
        auto write(InRange &&buf) -> size_type requires std::same_as<
            const_value_type,
            std::add_const_t<std::ranges::range_value_t<InRange>>>;

        // commit(n): mark n objects at the start of the buffer as being
        // readable data.
        auto commit(size_type n) -> size_type;

        // read(): read some data from this buffer and adjust the read window.
        // Returns the number of bytes copied.  If the buffer doesn't have
        // enough data to satisfy the request, the return value will be less
        // than the range size.
        template <std::ranges::contiguous_range InRange>
        auto read(InRange &&buf) -> size_type
            requires std::same_as<value_type,
                                  std::ranges::range_value_t<InRange>>;

        // discard(n): remove up to n characters from the read window.  Returns
        // the number of characters removed.
        auto discard(size_type n) -> size_type;

        // Return our read window.
        auto readable_ranges() -> std::vector<std::span<const_value_type>>;

        // Return our write window.
        auto writable_ranges() -> std::vector<std::span<value_type>>;
    };

    template <typename Char, std::size_t buffer_size>
    auto fixed_buffer<Char, buffer_size>::reset() -> void {
        data = std::span<Char, buffer_size>(data_array);

        // No data to read.
        read_window = data.subspan(0, 0);

        // All space available for writes.
        write_window = data;
    }

    template <typename Char, std::size_t buffer_size>
    template <std::ranges::contiguous_range InRange>
    auto fixed_buffer<Char, buffer_size>::write(InRange &&buf) -> size_type
        requires std::same_as<
            const_value_type,
            std::add_const_t<std::ranges::range_value_t<InRange>>> {

        // Determine how many objects we want to write.
        auto can_write = std::min(std::ranges::size(buf), write_window.size());

        // Create a subrange of the input buf for the data we want to write.
        auto will_write = buf | std::ranges::views::take(can_write);
        std::ranges::copy(will_write, write_window.begin());

        // Remove the used space from the write window
        write_window = write_window.subspan(can_write);

        // Increase the read window to contain the new data.
        auto read_offset = std::distance(data.data(), read_window.data());
        read_window = std::span<Char>(data.data() + read_offset,
                                      data.data() + read_offset
                                          + read_window.size() + can_write);

        return can_write;
    }

    /*
     * fixed_buffer::commit()
     */
    template <typename Char, std::size_t buffer_size>
    auto fixed_buffer<Char, buffer_size>::commit(size_type n) -> size_type {
        auto can_commit = std::min(n, write_window.size());

        // Remove the used space from the write window
        write_window = write_window.subspan(can_commit);

        // Increase the read window to contain the new data.
        auto read_offset = std::distance(data.data(), read_window.data());
        read_window = std::span<Char>(data.data() + read_offset,
                                      data.data() + read_offset
                                          + read_window.size() + can_commit);
        return can_commit;
    }

    /*
     * fixed_buffer::read()
     */
    template <typename Char, std::size_t buffer_size>
    template <std::ranges::contiguous_range InRange>
    auto fixed_buffer<Char, buffer_size>::read(InRange &&buf) -> size_type
        requires std::same_as<value_type, std::ranges::range_value_t<InRange>> {

        auto can_read = std::min(std::ranges::size(buf), read_window.size());

        auto will_read = read_window.subspan(0, can_read);
        std::ranges::copy(will_read, std::ranges::begin(buf));
        read_window = read_window.subspan(can_read);
        return can_read;
    }

    /*
     * fixed_buffer::discard()
     */
    template <typename Char, std::size_t buffer_size>
    auto fixed_buffer<Char, buffer_size>::discard(size_type n) -> size_type {
        auto can_remove = std::min(n, read_window.size());
        read_window = read_window.subspan(can_remove);
        return can_remove;
    }

    /*
     * fixed_buffer::readable_ranges()
     */
    template <typename Char, std::size_t buffer_size>
    auto fixed_buffer<Char, buffer_size>::readable_ranges()
        -> std::vector<std::span<const_value_type>> {

        return { read_window };
    }

    /*
     * fixed_buffer::writable_ranges()
     */
    template <typename Char, std::size_t buffer_size>
    auto fixed_buffer<Char, buffer_size>::writable_ranges()
        -> std::vector<std::span<value_type>> {

        return { write_window };
    }

    // fixed_buffer is a buffer.
    static_assert(buffer<fixed_buffer<char, 4096>>);

} // namespace sk

#endif // SK_BUFFER_FIXED_BUFFER_HXX_INCLUDED
